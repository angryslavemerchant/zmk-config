#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>

/* Smaller base chunk per activation; Smooth Scrolling will make <120 deltas useful */
#define ZMK_POINTING_DEFAULT_SCRL_VAL 100

#include <dt-bindings/zmk/pointing.h>
#include <input/processors.dtsi>
#include <zephyr/dt-bindings/input/input-event-codes.h>

/ {
    /* Scale the REL_WHEEL output; fractions work thanks to track-remainders */
    input_processors {
        zip_wheel_scaler: zip_wheel_scaler {
            compatible = "zmk,input-processor-scaler";
            #input-processor-cells = <2>;
            type = <INPUT_EV_REL>;
            codes = <INPUT_REL_WHEEL>;
            track-remainders;
        };
    };

    behaviors {
        /* Use explicit wheel deltas instead of SCRL_* */
        scroll: scroll_control {
            compatible = "zmk,behavior-sensor-rotate";
            #sensor-binding-cells = <0>;
            /* CW uses +25, CCW uses -25 (base “chunk” per detent) */
            bindings = <&msc MOVE_Y(25)>, <&msc MOVE_Y(-25)>;
            tap-ms = <40>;
        };
    };

    keymap {
        compatible = "zmk,keymap";

        /* Layer 0: Slow (1× of 25) */
        default_layer {
            display-name = "Slow";
            bindings = <&to 1>;
            sensor-bindings = <&scroll>;
        };

        /* Layer 1: Normal (2× -> 50 per detent) */
        normal_layer {
            display-name = "Normal";
            bindings = <&to 2>;
            sensor-bindings = <&scroll>;
        };

        /* Layer 2: Fast (4× -> 100 per detent) */
        fast_layer {
            display-name = "Fast";
            bindings = <&to 3>;
            sensor-bindings = <&scroll>;
        };

        /* Layer 3: Turbo (8× -> 200 per detent) */
        turbo_layer {
            display-name = "Turbo";
            bindings = <&to 0>;
            sensor-bindings = <&scroll>;
        };
    };
};

/* Per-layer scaling of REL_WHEEL output (applies to MOVE_Y deltas) */
&msc_input_listener {
    slow {
        layers = <0>;
        input-processors = <&zip_wheel_scaler 1 1>;   /* 1× => 25 */
    };

    normal {
        layers = <1>;
        input-processors = <&zip_wheel_scaler 2 1>;   /* 2× => 50 */
    };

    fast {
        layers = <2>;
        input-processors = <&zip_wheel_scaler 4 1>;   /* 4× => 100 */
    };

    turbo {
        layers = <3>;
        input-processors = <&zip_wheel_scaler 8 1>;   /* 8× => 200 */
    };
};
